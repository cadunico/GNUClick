#!/usr/bin/env python3
# photobooth.py - Photo Booth leve com Tkinter + OpenCV + SVG overlay
# - Pastas esperadas no diret√≥rio: molduras/ (svg), fotos/, sons/
# - Nome de arquivo salvo: YYYYMMDD_HHMMSS_clckgnu.png

import os
import sys
import time
import json
import glob
import threading
import datetime
import subprocess
from pathlib import Path
from queue import Queue, Empty
import io, shutil, tempfile

# Tkinter (builtin)
import tkinter as tk
from tkinter import ttk, messagebox

# Pillow
try:
    from PIL import Image, ImageTk, ImageOps
except Exception as e:
    print("Pillow n√£o encontrado. Rode install.sh e ative o venv.")
    raise

# OpenCV
try:
    import cv2
except Exception as e:
    print("OpenCV (cv2) n√£o encontrado. Rode install.sh e ative o venv.")
    raise

# cairosvg optional
HAS_CAIROSVG = False
try:
    import cairosvg
    HAS_CAIROSVG = True
except Exception:
    HAS_CAIROSVG = False

# playsound optional
HAS_PLAYSOUND = False
try:
    from playsound import playsound
    HAS_PLAYSOUND = True
except Exception:
    HAS_PLAYSOUND = False

# Paths and config
BASE_DIR = Path.cwd()
FRAMES_DIR = BASE_DIR / "molduras"
PHOTOS_DIR = BASE_DIR / "fotos"
SOUNDS_DIR = BASE_DIR / "sons"
CONFIG_PATH = BASE_DIR / ".photobooth_config.json"

FRAMES_DIR.mkdir(exist_ok=True)
PHOTOS_DIR.mkdir(exist_ok=True)
SOUNDS_DIR.mkdir(exist_ok=True)

# default config
DEFAULT_CONFIG = {
    "camera_index": 0,
    "hotkey": "space",
    "last_frame": None
}

def load_config():
    if CONFIG_PATH.exists():
        try:
            with open(CONFIG_PATH, "r", encoding="utf-8") as f:
                cfg = json.load(f)
            return {**DEFAULT_CONFIG, **cfg}
        except Exception:
            return DEFAULT_CONFIG.copy()
    return DEFAULT_CONFIG.copy()

def save_config(cfg):
    try:
        with open(CONFIG_PATH, "w", encoding="utf-8") as f:
            json.dump(cfg, f, indent=2)
    except Exception:
        pass

def timestamp_filename():
    now = datetime.datetime.datetime.now() if False else datetime.datetime.now()
    return now.strftime("%Y%m%d_%H%M%S_clckgnu.png")

def list_video_devices(max_scan=8):
    # Prefer /dev/video* listing
    devs = sorted(glob.glob("/dev/video*"))
    if devs:
        return devs
    found = []
    for i in range(max_scan):
        cap = cv2.VideoCapture(i, cv2.CAP_V4L2 if hasattr(cv2, "CAP_V4L2") else 0)
        if cap is None or not cap.isOpened():
            if cap:
                cap.release()
            continue
        cap.release()
        found.append(i)
    return found

def rasterize_svg_to_image(svg_path, target_w, target_h):
    svg_path = str(svg_path)
    if not os.path.exists(svg_path):
        return None
    # try cairosvg
    if HAS_CAIROSVG:
        try:
            png_bytes = cairosvg.svg2png(url=svg_path, output_width=target_w, output_height=target_h)
            return Image.open(io.BytesIO(png_bytes)).convert("RGBA")
        except Exception as e:
            print("cairosvg erro:", e)
    # inkscape fallback
    inkscape = shutil.which("inkscape")
    if inkscape:
        try:
            tmp = tempfile.NamedTemporaryFile(suffix=".png", delete=False)
            tmp.close()
            cmd = [inkscape, svg_path, "--export-type=png", f"--export-filename={tmp.name}", f"--export-width={target_w}", f"--export-height={target_h}"]
            res = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            if res.returncode != 0:
                # try legacy fallback
                cmd2 = [inkscape, svg_path, "--export-png", tmp.name, f"--export-width={target_w}", f"--export-height={target_h}"]
                subprocess.run(cmd2, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            if os.path.exists(tmp.name):
                img = Image.open(tmp.name).convert("RGBA")
                os.unlink(tmp.name)
                return img
        except Exception as e:
            print("inkscape erro:", e)
    # fallback: transparent placeholder
    return Image.new("RGBA", (target_w, target_h), (0,0,0,0))

# shutter sound
def play_shutter_sound():
    # prefer sons/click.wav or click.mp3
    candidates = [SOUNDS_DIR / "click.wav", SOUNDS_DIR / "click.mp3", SOUNDS_DIR / "click.ogg"]
    chosen = None
    for c in candidates:
        if c.exists():
            chosen = str(c)
            break
    if chosen is None:
        # nothing found ‚Äì try the wav generated by installer
        gen = SOUNDS_DIR / "click.wav"
        if gen.exists():
            chosen = str(gen)
    if not chosen:
        # nothing to play
        return
    # try playsound
    if HAS_PLAYSOUND:
        try:
            playsound(chosen, block=False)
            return
        except Exception:
            pass
    # fallback to aplay (linux)
    if shutil.which("aplay"):
        try:
            # spawn background so UI isn't blocked
            subprocess.Popen(["aplay", chosen], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            return
        except Exception:
            pass
    # fallback to ffplay if exists (non-blocking)
    if shutil.which("ffplay"):
        subprocess.Popen(["ffplay", "-nodisp", "-autoexit", "-loglevel", "quiet", chosen], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

# Ensure directories with full permissions
def ensure_directories():
    for d in (FRAMES_DIR, PHOTOS_DIR, SOUNDS_DIR):
        try:
            d.mkdir(parents=True, exist_ok=True)
            os.chmod(str(d), 0o777)
        except Exception:
            pass

# Main App
class PhotoBoothApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Photo Booth")
        self.config = load_config()
        self.cap = None
        self.capture_thread = None
        self.running = False
        self.frame_queue = Queue(maxsize=2)
        self.current_frame = None
        self.preview_imgtk = None
        self.selected_frame_path = None
        self.frame_overlay_pil = None
        self.thumbnails = []
        self.svg_list = []
        self.hotkey = self.config.get("hotkey", "space")
        self.camera_index = self.config.get("camera_index", 0)
        self.counting = False

        # preview resolution (adjust for Pi if needed)
        self.preview_w = 960
        self.preview_h = 540

        # UI layout
        self.canvas = tk.Canvas(root, width=self.preview_w, height=self.preview_h, bg="black")
        self.canvas.grid(row=0, column=0, columnspan=3, padx=8, pady=8)

        self.btn_snap = ttk.Button(root, text="üì∏", command=self.start_countdown, width=6)
        self.btn_snap.grid(row=1, column=0, sticky="ew", padx=6)
        self.btn_settings = ttk.Button(root, text="‚öôÔ∏è", command=self.open_settings, width=6)
        self.btn_settings.grid(row=1, column=1, sticky="ew", padx=6)
        self.btn_exit = ttk.Button(root, text="üö™", command=self.quit, width=6)
        self.btn_exit.grid(row=1, column=2, sticky="ew", padx=6)

        # thumbnails carousel
        self.thumb_frame = tk.Frame(root)
        self.thumb_frame.grid(row=2, column=0, columnspan=3, sticky="ew", padx=8, pady=(4,12))
        self.thumb_canvas = tk.Canvas(self.thumb_frame, height=100)
        self.thumb_hbar = ttk.Scrollbar(self.thumb_frame, orient="horizontal", command=self.thumb_canvas.xview)
        self.thumb_canvas.configure(xscrollcommand=self.thumb_hbar.set)
        self.thumb_canvas.pack(side="top", fill="x", expand=True)
        self.thumb_hbar.pack(side="top", fill="x")
        self.thumb_inner = tk.Frame(self.thumb_canvas)
        self.thumb_window = self.thumb_canvas.create_window((0,0), window=self.thumb_inner, anchor="nw")
        self.thumb_inner.bind("<Configure>", lambda e: self.thumb_canvas.configure(scrollregion=self.thumb_canvas.bbox("all")))

        # key bindings
        root.bind("<Key>", self.keypress)
        root.bind("<space>", lambda e: self.start_countdown())

        ensure_directories()
        self.load_svg_list()
        self.open_camera(self.camera_index)
        self.update_loop()

    def load_svg_list(self):
        files = sorted(FRAMES_DIR.glob("*.svg"))
        self.svg_list = files
        # clear UI thumbs
        for w in self.thumb_inner.winfo_children():
            w.destroy()
        self.thumbnails = []
        for idx, svg_path in enumerate(self.svg_list):
            thumb = rasterize_svg_to_image(svg_path, 200, 112)
            if thumb is None:
                thumb = Image.new("RGBA", (200,112), (200,200,200,255))
            imgtk = ImageTk.PhotoImage(thumb)
            lbl = tk.Label(self.thumb_inner, image=imgtk, bd=2, relief="ridge")
            lbl.image = imgtk
            lbl.grid(row=0, column=idx, padx=4)
            lbl.bind("<Button-1>", lambda e, p=svg_path: self.select_frame(p))
            self.thumbnails.append((svg_path, thumb))
        if self.svg_list:
            sel = self.config.get("last_frame")
            if sel and Path(sel).exists():
                self.select_frame(Path(sel))
            else:
                self.select_frame(self.svg_list[0])

    def select_frame(self, path):
        self.selected_frame_path = Path(path)
        self.config['last_frame'] = str(path)
        save_config(self.config)
        ov = rasterize_svg_to_image(self.selected_frame_path, self.preview_w, self.preview_h)
        self.frame_overlay_pil = ov

    def open_camera(self, cam_index):
        try:
            if self.cap:
                self.running = False
                time.sleep(0.2)
                self.cap.release()
            try:
                if isinstance(cam_index, str) and str(cam_index).startswith("/dev/"):
                    self.cap = cv2.VideoCapture(cam_index)
                else:
                    self.cap = cv2.VideoCapture(int(cam_index))
            except Exception:
                self.cap = cv2.VideoCapture(int(cam_index))
            # attempt reasonable resolution
            self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, 1280)
            self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 720)
            self.running = True
            self.capture_thread = threading.Thread(target=self._capture_loop, daemon=True)
            self.capture_thread.start()
            self.camera_index = cam_index
            self.config['camera_index'] = cam_index
            save_config(self.config)
        except Exception as e:
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel abrir c√¢mera {cam_index}: {e}")

    def _capture_loop(self):
        while self.running:
            if not self.cap or not self.cap.isOpened():
                time.sleep(0.2); continue
            ret, frame = self.cap.read()
            if not ret:
                time.sleep(0.02); continue
            frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            try:
                if self.frame_queue.full():
                    _ = self.frame_queue.get_nowait()
                self.frame_queue.put_nowait(frame_rgb)
            except Exception:
                pass
            time.sleep(0.01)

    def update_loop(self):
        try:
            frame = self.frame_queue.get_nowait()
            self.current_frame = frame
        except Empty:
            frame = None
        if self.current_frame is not None:
            pil = Image.fromarray(self.current_frame)
            w, h = pil.size
            target_ratio = 16/9
            current_ratio = w / h
            if current_ratio > target_ratio:
                new_w = int(h * target_ratio)
                left = (w - new_w)//2
                pil = pil.crop((left, 0, left+new_w, h))
            else:
                new_h = int(w / target_ratio)
                top = (h - new_h)//2
                pil = pil.crop((0, top, w, top+new_h))
            pil = pil.resize((self.preview_w, self.preview_h), Image.LANCZOS)
            if self.frame_overlay_pil:
                ov = self.frame_overlay_pil
                if ov.size != pil.size:
                    ov = ov.resize(pil.size, Image.LANCZOS)
                    self.frame_overlay_pil = ov
                pil = Image.alpha_composite(pil.convert("RGBA"), ov)
            self.preview_imgtk = ImageTk.PhotoImage(pil)
            self.canvas.delete("all")
            self.canvas.create_image(0,0, image=self.preview_imgtk, anchor="nw")
        self.root.after(30, self.update_loop)

    def start_countdown(self):
        if self.counting:
            return
        self.counting = True
        def countdown_and_shoot():
            for i in (3,2,1):
                self.show_count_text(str(i))
                time.sleep(1)   # 1 second per number
            self.show_count_text("")  # clear
            # play shutter sound
            play_shutter_sound()
            # take photo
            self.take_photo()
            self.counting = False
        threading.Thread(target=countdown_and_shoot, daemon=True).start()

    def show_count_text(self, txt):
        self.canvas.delete("count")
        if txt:
            self.canvas.create_text(self.preview_w//2, self.preview_h//2, text=txt, font=("Helvetica", 120), fill="white", tag="count")
        else:
            self.canvas.delete("count")

    def take_photo(self):
        if self.current_frame is None:
            messagebox.showwarning("Aviso", "Nenhum quadro dispon√≠vel para capturar.")
            return
        pil = Image.fromarray(self.current_frame)
        w, h = pil.size
        target_ratio = 16/9
        current_ratio = w/h
        if current_ratio > target_ratio:
            new_w = int(h * target_ratio)
            left = (w - new_w)//2
            pil = pil.crop((left, 0, left+new_w, h))
            orientation = "landscape"
        else:
            new_h = int(w / target_ratio)
            top = (h - new_h)//2
            pil = pil.crop((0, top, w, top+new_h))
            orientation = "portrait"
        # overlay at full resolution
        if self.selected_frame_path:
            ov = rasterize_svg_to_image(self.selected_frame_path, pil.width, pil.height)
            if ov:
                pil = Image.alpha_composite(pil.convert("RGBA"), ov)
        out_path = PHOTOS_DIR / timestamp_filename()
        # ensure RGBA->RGB if no alpha
        try:
            pil.save(out_path)
            os.chmod(str(out_path), 0o666)
        except Exception:
            # try convert to RGB
            pil.convert("RGB").save(out_path)
            os.chmod(str(out_path), 0o666)
        print(f"Salva foto: {out_path} | orienta√ß√£o: {orientation}")
        # quick flash effect
        self.canvas.create_rectangle(0,0,self.preview_w,self.preview_h, outline="", fill="white", stipple="gray50", tag="flash")
        self.root.after(120, lambda: self.canvas.delete("flash"))

    def keypress(self, event):
        k = event.keysym.lower()
        if k == self.hotkey.lower():
            self.start_countdown()

    def open_settings(self):
        win = tk.Toplevel(self.root)
        win.title("Configura√ß√µes")
        tk.Label(win, text="Selecionar c√¢mera:").grid(row=0, column=0, sticky="w", padx=6, pady=6)
        devices = list_video_devices()
        dev_var = tk.StringVar(value=str(self.camera_index))
        cmb = ttk.Combobox(win, values=[str(d) for d in devices], textvariable=dev_var)
        cmb.grid(row=0, column=1, padx=6, pady=6)
        def apply_cam():
            val = dev_var.get()
            try:
                cam_val = int(val) if str(val).isdigit() else val
            except Exception:
                cam_val = val
            self.open_camera(cam_val)
            win.destroy()
        btn_apply = ttk.Button(win, text="Aplicar", command=apply_cam)
        btn_apply.grid(row=1, column=0, columnspan=2, pady=8)

        tk.Label(win, text="Tecla de atalho (ex: space, s, Return):").grid(row=2, column=0, sticky="w", padx=6, pady=6)
        hk_var = tk.StringVar(value=self.hotkey)
        hk_entry = ttk.Entry(win, textvariable=hk_var)
        hk_entry.grid(row=2, column=1, padx=6, pady=6)
        def apply_hotkey():
            hk = hk_var.get().strip()
            if hk:
                self.hotkey = hk
                self.config['hotkey'] = hk
                save_config(self.config)
                messagebox.showinfo("Hotkey", f"Hotkey definida para '{hk}'.")
            win.destroy()
        btn_hk = ttk.Button(win, text="Salvar Hotkey", command=apply_hotkey)
        btn_hk.grid(row=3, column=0, columnspan=2, pady=8)

    def quit(self):
        self.running = False
        if self.cap:
            try:
                self.cap.release()
            except Exception:
                pass
        try:
            self.root.quit()
            self.root.destroy()
        except Exception:
            pass

def main():
    ensure_directories()
    root = tk.Tk()
    app = PhotoBoothApp(root)
    root.mainloop()

if __name__ == "__main__":
    main()

